---
title: "TP2 - Réaliser une application de cartographie interactive avec Quarto et `bertin`"
format: 
  html:
    theme: custom.scss
    code-tools: true
    toc: false
    code-fold: false
    code-summary: "Show the code"
editor: visual
execute:
  echo: true
---

**L'objectif de ce TP est d'apprendre à créer des cartes interactives avec Quarto et la bibliothèque JavaScript `bertin`.**

![](img/banner.png)

**Responsables pédagogiques**

Manhamady OUEDRAOGO (Burkina Faso) & Nicolas LAMBERT (France)

**Ont participé à l'élaboration de ce module**

Claude GRASLAND (France), Souleymane Sidi TRAORE (Mali), Malika MADELIN (France), Sébastien REY-COYREHOURCQ (France), Vakaramoko BAMBA (Côte d'Ivoire), Hugues PECOUT (France), Yentougle MOUTORE (Togo), Bénédicte GARNIER (France), Côomlan Charles HOUNTON (Bénin), Pauline GLUSKI (France)

**Objectifs**

Le but de ce TP est de réaliser une application de cartographie sur le monde sur une page web. Pour cela, nous nous basons sur un tableau de données contenant 6 variables issues de la banque mondiale, disponibles de 1990 à 2021. Elles ont été harmonisées par Claude Grasland.

```{ojs}
//| echo: false
//| eval: true
prez = FileAttachment("data/worldbank_meta.csv").csv()
Inputs.table(prez, {  columns: [
    "shortcode",
    "indicator",
    "indicator_desc",
  ],
  header: {
    shortcode: "id",
    indicator: "indicateur",
    indicator_desc: "description",
  }})
```

# 1. Créer un document Quarto

Créez un document Quarto avec l'entête suivante :

::: copy
    ---
    title: "World Explorer"
    format:
      html:
        echo: false
        code-tools: true
        page-layout: full
    ---
:::

Copiez et collez en dessous le code suivant :

::: copy

``` {{ojs}}
//| panel: sidebar
"Le menu"
```

    ::: {.panel-tabset .ojs-track-layout}

    ## Carte

``` {{ojs}}
"La carte"
```

    ## Données

``` {{ojs}}
"Les données"
```

    ## Top 10

``` {{ojs}}
"le graphique"
```

    :::

``` {{ojs}}
"Annexe technique"
```
:::

Cliquez sur `Render` (ou *Ctrl+Shift+K*) pour voir apparaitre la structure de votre interface. Elle est composée de 6 parties :

-   Le <ins>titre</ins> (défini dans l'entête de votre document `title: "World Explorer"` ). À vous de remplacer le titre par la chaine de caractère de votre choix.
-   Le <ins>menu</ins> (sur la gauche). C'est dans ce *chunk* que nous allons placer des `Inputs` permettant à l'utilisateur d'interagir avec la carte.
-   La <ins>carte</ins> (sur la droite). C'est dans ce *chunk* que nous allons dessiner une carte avec la bibliothèque `bertin`.
-   Les <ins>données</ins> (sur la droite). C'est dans ce *chunk* que nous allons afficher le tableau de données derrière la carte.
-   Un <ins>graphique</ins> (sur la droite). C'est dans ce *chunk* que nous allons afficher un *bar plot*.
-   Les <ins>annexes techniques</ins> (en bas). Dans ce chunk, on écrira tout ce qui est nécéssaire à l'élaboration de l'appli (import des données, etc, mais qu'on ne souhaite pas afficher). Rappelez-vous qu'avec Observable JavaScript, l'ordre d'écriture n'a pas d'importance. On peut donc écrire du code à la fin du document, comme une annexe technique.

*NB: La carte et les données sont dans 2 onglets grace aux classes {.panel-tabset .ojs-track-layout}*

-   Sauvegardez.

# 2. Les données
Téléchargez les données et mettez-les dans un repertoire *data*.

<a href = "https://github.com/EE-CIST/CART3_cartodyn/raw/main/TP2/data/data.zip"><img src = "img/download.png" height= "50px"><img></a>

Dans le chunck de l'<ins>**annexe technique**</ins>, importez les données géométriques et attributaires qui se trouvent dans le répertoire data.

::: copy
```{ojs}
world = FileAttachment("data/world.json").json()
stats = FileAttachment("data/worldbank_data.csv").csv()
```
:::

Comme dit précédement, les données contiennent des indacteurs à plusieurs dates.

```{ojs}
//| echo: false
//| eval: true
Inputs.table(stats)
```

# 3. Le menu

Ici, on définit quelles interactions ont souhaite proposer à l'utilisateur.

Copiez et collez les lignes de code suivantes dans votre chunck <ins>menu</ins>.

-   Un slider pour choisir l'année

::: copy
```{ojs}
//| echo: true
//| eval: false
viewof year =  Inputs.range(
  [1990, 2019], 
  {value: 2019, step: 1, label: "Année"}
)
```
:::

-   Un slider pour configurer la taille des cercles

::: copy
```{ojs}
//| echo: true
//| eval: false
viewof k =  Inputs.range(
  [20, 100], 
  {value: 50, step: 1, label: "Rayon max"}
)
```
:::

-   Une liste déroulante pour choisir l'indicateur

::: copy
```{ojs}
//| echo: true
//| eval: false
meta = FileAttachment("data/worldbank_meta.csv").csv()
viewof indicator = Inputs.select(
  new Map(meta.map((d) => [d.indicator, d.shortcode])),
  { label: "Indicateur" }
)
```
:::

-   Une liste déroulate pour choisir la projection cartographique

::: copy
```{ojs}
//| echo: true
//| eval: false
projections = ["Polar", "InterruptedSinusoidal", "Armadillo", "Baker", "Gingery", "Berghaus", "Loximuthal", "Healpix", "InterruptedMollweideHemispheres", "Miller", "Aitoff", "Spilhaus"]
viewof proj = Inputs.select(projections, {label: "Projection"})
```
:::

- La couleur

::: copy
```{ojs}
//| echo: true
//| eval: false
viewof color = Inputs.color({label: "couleur", value: "#4682b4"})
```
:::

On obtient le menu suivant où `year` correspond à l'année, `k` correspond à la taille des cercles, `indicator` correspond au nom de la variable, `proj` correspond à la projection cartographique et `color` correspond à la couleur des symboles.

::: copy
```{ojs}
//| echo: false
//| eval: true
viewof year =  Inputs.range(
  [1990, 2019], 
  {value: 2019, step: 1, label: "Année"}
)
viewof k =  Inputs.range(
  [20, 100], 
  {value: 50, step: 1, label: "Rayon max"}
)
meta = FileAttachment("data/worldbank_meta.csv").csv()
viewof indicator = Inputs.select(
  new Map(meta.map((d) => [d.indicator, d.shortcode])),
  { label: "Indicateur" }
)
projections = ["Polar", "InterruptedSinusoidal", "Armadillo", "Baker", "Gingery", "Berghaus", "Loximuthal", "Healpix", "InterruptedMollweideHemispheres", "Miller", "Aitoff", "Spilhaus"]
viewof proj = Inputs.select(projections, {label: "Projection"})
viewof color = Inputs.color({label: "couleur", value: "#4682b4"})
```
:::

# 4. Mise en forme des données

Avant de construire la carte, nous avons besoin de manipuler un peu les données en créant un tableau contenant uniquement l'année séléctionnée et en effectuant une jointure entre les données et le fond de carte. On effectue ces opérations dans la partie <ins>annexe technique</ins>. On a besoin de charger la bibliothèque `bertin`.

::: copy
```{ojs}
bertin = require("bertin@1.5.9")
statsyear = stats.filter(d => d.date == year)
data = bertin.merge(world, "id", statsyear, "iso3c")
```
:::

On a aussi besoin de récupérer une valeur de réference pour chaque indicateur pour rendre comparables la taille des symboles d'une année à l'année sur l'autre.

::: copy
```{ojs}
varmax = d3.max(stats.filter(d => d.date == 2019), d => +d[indicator])
```
:::

Après ces opérations, l'objet `data` contient les géométries et les données pour l'année séléctionnée.

# 5. Réalisation de la carte

Ici, on réalise la carte dans la chuck <ins>**carte**</ins> avec la bibliothèque bertin.

::: copy
```{ojs}
//| echo: true
//| eval: false
bertin.draw({
params: {projection: proj, clip: true }, 
layers:[
  {type: "bubble", geojson: data, values: indicator, 
  fill: color, dorling: true, fixmax: varmax, k, 
  tooltip: ["$name",d => d.properties[indicator]]},
  {geojson: world, fill: "#CCC"},
  {type: "graticule"},  
  {type: "outline"}
]})
```
:::

# 6. Affichage des données

Ici, on ajoute un tableau de données dans la chuck <ins>données</ins>.

::: copy
```{ojs}
//| echo: true
//| eval: false
Inputs.table(statsyear, {  columns: [
    "country",
    "capital_city",
    "region",
    indicator
  ]})
```
:::

# 7. Réalisation du graphique

On souhaite réaliser un diagramme en barres avec les N pays qui ont les plus fortes valeurs sur l'indicateur séléctionné. Nous récupérons donc l'objet `stats` qui contient les données, nous le trions, et ne gardons que les N premières valeurs. N est défini dans un slider. Le graphique est réalisé avec la bibliothèqe Plot. 

Ajoutez le code ci-dessous chuck <ins>graphique</ins>.

::: copy
```{ojs}
//| echo: true
//| eval: false
viewof topnb = Inputs.range([5, 30], {label: "Nombre de pays représentés", step: 1})
top = statsyear.sort((a, b) => d3.descending(+a[indicator], +b[indicator]))
  .slice(0, topnb)
Plot.plot({
	marginLeft: 60,
  marks: [
    Plot.barY(top, {
      x: "iso3c",
      y: indicator,
      sort: { x: "y", reverse: true },
      fill: color
    }),
    Plot.ruleY([0])
  ]
})
```
:::

# 7. C'est fini !

Appuyez sur `Render` pour voir le résultat. La solution est disponible [ici](https://ee-cist.github.io/CART3_cartodyn/app/index.html).
