---
title: "TP2 - R√©aliser une *single page application* avec Quarto et `bertin`"
format: 
  html:
    theme: custom.scss
    code-tools: true
    toc: false
    code-fold: false
    code-summary: "Show the code"
editor: visual
execute:
  echo: true
---

**L'objectif de ce TP est d'apprendre √† cr√©er des cartes interactives avec Quarto et la biblioth√®que JavaScript `bertin`.**

![](img/banner.png)

**Responsables p√©dagogiques**

Manhamady OUEDRAOGO (Burkina Faso) & Nicolas LAMBERT (France)

**Ont particip√© √† l'√©laboration de ce module**

Claude GRASLAND (France), Souleymane Sidi TRAORE (Mali), Malika MADELIN (France), S√©bastien REY-COYREHOURCQ (France), Vakaramoko BAMBA (C√¥te d'Ivoire), Hugues PECOUT (France), Yentougle MOUTORE (Togo), B√©n√©dicte GARNIER (France), C√¥omlan Charles HOUNTON (B√©nin), Pauline GLUSKI (France)

# Introduction

**Objectifs**

Le but de ce TP est de r√©aliser une application de cartographie √† l'√©chelle mondiale sur une page web *pleine page*. d'un point de vue technique, on parlera de *single page application* (SPA). Les bases et pr√©requis n√©cessaires √† la bonne compr√©hension de ce TP sont disponibles via ce [cours introductif](https://ee-cist.github.io/CART3_cartodyn/intro/docs/index.html#/title-slide) et ce premier [TP](https://ee-cist.github.io/CART3_cartodyn/TP1/docs/index.html). Merci de proc√©der dans cet ordre.

**Donn√©es**

Pour cet exercice, nous nous basons sur un tableau de donn√©es contenant 6 variables issues de la banque mondiale, disponibles de 1990 √† 2021. Elles ont √©t√© harmonis√©es par Claude Grasland.

```{ojs}
//| echo: false
//| eval: true
prez = FileAttachment("data/worldbank_meta.csv").csv()
Inputs.table(prez, {  columns: [
    "shortcode",
    "indicator",
    "indicator_desc",
  ],
  header: {
    shortcode: "id",
    indicator: "indicateur",
    indicator_desc: "description",
  }})
```

# 1. Cr√©er un document Quarto

Dans Rstudio, cr√©ez un document Quarto avec l'ent√™te suivante :

::: copy
    ---
    title: "World Explorer"
    format:
      html:
        echo: false
        code-tools: true
        page-layout: full
    ---
:::

- `echo: false` permet de ne pas afficher le code dans le document final 
- `code-tools: true` permet de donner acc√®s au code source en cliquant sur `</> Code` en haut ) droite de la page.
- `page-layout: full` permet de d√©finir une disposition *pleine page*

Copiez et collez en dessous le code suivant :

::: copy

``` {{ojs}}
//| panel: sidebar
"Le menu"
```

    ::: {.panel-tabset .ojs-track-layout}

    ## Carte

``` {{ojs}}
"La carte"
```

    ## Donn√©es

``` {{ojs}}
"Les donn√©es"
```

    ## Top 10

``` {{ojs}}
"le graphique"
```

    :::

``` {{ojs}}
"Annexe technique"
```
:::

Cliquez sur `Render` (ou *Ctrl+Shift+K*) pour voir apparaitre la structure de votre interface. Elle est compos√©e de 6 parties :

-   Le <ins>titre</ins> (d√©fini dans l'ent√™te de votre document `title: "World Explorer"` ). √Ä vous de remplacer le titre par la chaine de caract√®re de votre choix.
-   Le <ins>menu</ins> (sur la gauche). C'est dans ce *chunk* que nous allons placer des `Inputs` permettant √† l'utilisateur d'interagir avec la carte.
-   La <ins>carte</ins> (sur la droite). C'est dans ce *chunk* que nous allons dessiner une carte avec la biblioth√®que `bertin`.
-   Les <ins>donn√©es</ins> (sur la droite). C'est dans ce *chunk* que nous allons afficher le tableau de donn√©es derri√®re la carte.
-   Un <ins>graphique</ins> (sur la droite). C'est dans ce *chunk* que nous allons afficher un *bar plot*.
-   Les <ins>annexes techniques</ins> (en bas). Dans ce chunk, on √©crira tout ce qui est n√©c√©ssaire √† l'√©laboration de l'appli (import des donn√©es, etc, mais qu'on ne souhaite pas afficher). Rappelez-vous qu'avec Observable JavaScript, l'ordre d'√©criture n'a pas d'importance. On peut donc √©crire du code √† la fin du document, comme une annexe technique.

*NB: La carte, les donn√©es et le graphique sont plac√©s dans 3 onglets grace aux classes {.panel-tabset .ojs-track-layout}*

-   Sauvegardez.

# 2. Les donn√©es
T√©l√©chargez les donn√©es et mettez-les dans un repertoire *data*.

<a href = "https://github.com/EE-CIST/CART3_cartodyn/raw/main/TP2/data/data.zip"><img src = "img/download.png" height= "50px"><img></a>

Dans le chunck de l'<ins>**annexe technique**</ins>, importez les donn√©es g√©om√©triques et attributaires qui se trouvent dans le r√©pertoire data.

::: copy
```{ojs}
world = FileAttachment("data/world.json").json()
stats = FileAttachment("data/worldbank_data.csv").csv()
```
:::

Comme dit pr√©c√©dement, les donn√©es contiennent des indicateurs √† plusieurs dates.

```{ojs}
//| echo: false
//| eval: true
Inputs.table(stats)
```

# 3. Le menu

Ici, on d√©finit quelles interactions ont souhaite proposer √† l'utilisateur.

Copiez et collez les lignes de code suivantes dans votre chunck <ins>**menu**</ins>.

-   Un slider pour choisir l'ann√©e

::: copy
```{ojs}
//| echo: true
//| eval: false
viewof year =  Inputs.range(
  [1990, 2019], 
  {value: 2019, step: 1, label: "Ann√©e"}
)
```
:::

-   Un slider pour configurer la taille des cercles

::: copy
```{ojs}
//| echo: true
//| eval: false
viewof k =  Inputs.range(
  [20, 100], 
  {value: 50, step: 1, label: "Rayon max"}
)
```
:::

-   Une liste d√©roulante pour choisir l'indicateur

::: copy
```{ojs}
//| echo: true
//| eval: false
meta = FileAttachment("data/worldbank_meta.csv").csv()
viewof indicator = Inputs.select(
  new Map(meta.map((d) => [d.indicator, d.shortcode])),
  { label: "Indicateur" }
)
```
:::

-   Une liste d√©roulante pour choisir la projection cartographique

::: copy
```{ojs}
//| echo: true
//| eval: false
projections = ["InterruptedSinusoidal", "Armadillo", "Baker", "Gingery", "Berghaus", "Loximuthal", "Healpix", "InterruptedMollweideHemispheres", "Miller", "Aitoff"]
viewof proj = Inputs.select(projections, {label: "Projection", width: 350})
```
:::

- Deux sliders pour d√©finir le centre de projection. De -180 √† +180 en longitude. De -90 √† +90 en latitude. 

::: copy
```{ojs}
//| echo: true
//| eval: false
viewof x =  Inputs.range( [-180, 180], {value: 0, step: 1, label: "Rotation (x)"} )
viewof y =  Inputs.range( [-90, 90], {value: 0, step: 1, label: "Rotation (y)"} )
```
:::

- La couleur des symboles

::: copy
```{ojs}
//| echo: true
//| eval: false
viewof color = Inputs.color({label: "couleur", value: "#4682b4"})
```
:::

-   Un slider pour d√©finir le niveau de g√©n√©ralisation du fond de carte

::: copy
```{ojs}
//| echo: true
//| eval: false
viewof simpl =  Inputs.range(
  [0, 1], 
  {value: 1, step: 0.1, label: "Simplification"}
)
```
:::


On obtient le menu suivant o√π `year` correspond √† l'ann√©e, `k` correspond √† la taille des cercles, `indicator` correspond au nom de la variable, `proj` correspond √† la projection cartographique, `color` correspond √† la couleur des symboles et `simpl` correspond au niveau de g√©n√©ralisation du fond de carte. 

::: copy
```{ojs}
//| echo: false
//| eval: true
viewof year =  Inputs.range(
  [1990, 2019], 
  {value: 2019, step: 1, label: "Ann√©e"}
)
viewof k =  Inputs.range(
  [20, 100], 
  {value: 50, step: 1, label: "Rayon max"}
)
meta = FileAttachment("data/worldbank_meta.csv").csv()
viewof indicator = Inputs.select(
  new Map(meta.map((d) => [d.indicator, d.shortcode])),
  { label: "Indicateur" }
)
projections = ["InterruptedSinusoidal", "Armadillo", "Baker", "Gingery", "Berghaus", "Loximuthal", "Healpix", "InterruptedMollweideHemispheres", "Miller", "Aitoff"]
viewof proj = Inputs.select(projections, {label: "Projection", width: 350})
viewof x =  Inputs.range( [-180, 180], {value: 0, step: 1, label: "Rotation (x)"} )
  viewof y =  Inputs.range( [-90, 90], {value: 0, step: 1, label: "Rotation (y)"} )
viewof color = Inputs.color({label: "couleur", value: "#4682b4"})
viewof simpl =  Inputs.range( [0.01, 0.5], {value: 0.2, label: "Simplification"} )
```
:::

# 4. Mise en forme des donn√©es

Avant de construire la carte, nous avons besoin de manipuler un peu les donn√©es. On effectue ces op√©rations dans la partie <ins>**annexe technique**</ins>.  Plusieurs op√©rations son n√©c√©ssaires: 

Tout d'abord, on r√©alise une g√©n√©ralisation du fond de carte avec la biblioth√®que `geotoolbox` qui permet de faire simplement la plupart des op√©rations SIG utiles en cartographie ([voir](https://github.com/neocarto/geotoolbox)). On peut la charger directement ou la t√©l√©charger [ici](https://cdn.jsdelivr.net/npm/geotoolbox@1.9.3) poyr travailler sans connexion internet.

::: copy
```{ojs}
geo = require("geotoolbox@1.9.3")
// ou geo = require("./lib/geotoolbox.js")
world2 = geo.simplify(world, {k: simpl})
```
:::

Puis, on cr√©e un tableau contenant uniquement l'ann√©e s√©l√©ctionn√©e et on effectue une jointure entre les donn√©es et le fond de carte. On a besoin de charger la biblioth√®que `bertin` (*on peut aussi t√©l√©charger la biblioth√®que [ici](https://cdn.jsdelivr.net/npm/bertin@1.6)*).

::: copy
```{ojs}
bertin = require("bertin@1.6")
// ou bertin = require("./lib/bertin.js")
statsyear = stats.filter(d => d.date == year)
data = bertin.merge(world2, "id", statsyear, "iso3c")
```
:::

Pour g√©n√©raliser le fond de carte, on utilise la biblioth√®que `geotoolbox` qui permet de faire simplement la plu√¢rt des op√©rations SIG itiles en cartographies ([voir](https://github.com/neocarto/geotoolbox)). Comme pr√©c√©dement, on peut la charger directement ou la t√©l√©charger [ici](https://cdn.jsdelivr.net/npm/geotoolbox@1.9.3).



On a aussi besoin de r√©cup√©rer une valeur de r√©ference pour chaque indicateur pour rendre comparables la taille des symboles d'une ann√©e √† l'ann√©e sur l'autre.

::: copy
```{ojs}
varmax = d3.max(stats.filter(d => d.date == 2019), d => +d[indicator])
```
:::

Apr√®s ces op√©rations, l'objet `data` contient les g√©om√©tries et les donn√©es pour l'ann√©e s√©l√©ctionn√©e.

# 5. R√©alisation de la carte

Ici, on r√©alise la carte dans la chuck <ins>**carte**</ins> avec la biblioth√®que bertin.

Tout d'abord, on fabrique le titre en concatenant le nom de la variable et l'ann√©e.

::: copy
```{ojs}
title = meta.map((d) => [d.indicator, d.shortcode]).find((d) => d[1] == indicator)[0] + " in " + year
```
:::

Puis, on dessine la carte

::: copy
```{ojs}
//| echo: true
//| eval: false
bertin.draw({
params: {projection: proj + `.rotate([${x}, ${y}])`, clip: true },
layers:[
  {type: "header", text: title},
  {type: "bubble", 
    geojson: data,
    values: indicator, 
    fill: color,
    fixmax: varmax,
    k, 
    tooltip: ["$name",d => d.properties[indicator]]
  },
  {geojson: world, fill: "#CCC"},
  {type: "graticule"},  
  {type: "outline"}
]})
```
:::

# 6. Affichage des donn√©es

Ici, on ajoute un tableau de donn√©es dans la chuck <ins>donn√©es</ins>.

::: copy
```{ojs}
//| echo: true
//| eval: false
Inputs.table(statsyear, {  columns: [
    "country",
    "capital_city",
    "region",
    indicator
  ]})
```
:::

# 7. R√©alisation du graphique

On souhaite r√©aliser un diagramme en barres avec les N pays qui ont les plus fortes valeurs sur l'indicateur s√©l√©ctionn√©. Nous r√©cup√©rons donc l'objet `stats` qui contient les donn√©es, nous le trions, et ne gardons que les N premi√®res valeurs. N est d√©fini dans un slider. Le graphique est r√©alis√© avec la biblioth√®qe Plot. 

Ajoutez le code ci-dessous chuck <ins>**graphique**</ins>.

::: copy
```{ojs}
//| echo: true
//| eval: false
viewof topnb = Inputs.range([5, 30], {label: "Nombre de pays repr√©sent√©s", step: 1})
top = statsyear.sort((a, b) => d3.descending(+a[indicator], +b[indicator]))
  .slice(0, topnb)
Plot.plot({
	marginLeft: 60,
  marks: [
    Plot.barY(top, {
      x: "iso3c",
      y: indicator,
      sort: { x: "y", reverse: true },
      fill: color
    }),
    Plot.ruleY([0])
  ]
})
```
:::

# 7. C'est fini !

Appuyez sur `Render` pour voir le r√©sultat. La solution est disponible [ici](https://ee-cist.github.io/CART3_cartodyn/app/index.html).

# 8. Aller plus loin

Cette application est largement perfectible. Une piste possible d'am√©lioration serait de remplacer le slider des ann√©es par un bouton play pour faire une vraie carte anim√©e. Une solution consiste √† utiliser l'input `scrubber` d√©velop√© par Mike Bostock : [https://observablehq.com/@mbostock/scrubber](https://observablehq.com/@mbostock/scrubber).

Deux options sont possibles. Vous pouvez importer la fonction depuis Observable.

::: copy
```{ojs}
//| echo: true
//| eval: false
import {Scrubber} from "@mbostock/scrubber"
```
:::

Ou copier le code de la fonction qui se trouve sur [cette page](https://observablehq.com/@mbostock/scrubber).

Puis, remplacez le slider des ann√©es par :

::: copy
```{ojs}
//| echo: true
//| eval: false
viewof year = Scrubber(d3.range(1990, 2019), { autoplay: false })
```
:::

Et pour encore plus de fun ü•≥, vous pouvez aussi vous amuser √† utiliser un *scrubber* √† la place du slider Rotate (x).


