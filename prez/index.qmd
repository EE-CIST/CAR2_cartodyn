---
title: "Cartographie thÃ©matique avec ojs"
subtitle: "bla bla bla"
author: "Nicolas Lambert"
date: 03/08/2023
lang: fr
date-format: "DD MMM YYYY"
title-slide-attributes:
  data-background-color: black
  data-background-image: img/nice.jpg
  data-background-size: cover
  data-background-opacity: "0.5"
format:
  revealjs:
    smaller: true
    scrollable: true
    theme: [simple, custom.scss]
editor: visual
execute:
  echo: true
---

# Intro

Ce qu'on va faire. Apprendre Ã  faire des cartes animÃ©s et interactives avec Observable javascript et bertin.js dans Quarto. Ce qu'on ne va pas faire : apprendre Ã  programmer en javascript

## sss

# Javascript

Historique du web Avant le web Ã©tait statique Creation de js Pas crÃ©Ã© au dÃ©part pour la visu de donnÃ©es. Avantages. InconvÃ©nients. Les dÃ©boires du dÃ©but. Langage qui peut Ãªtre Ã©tendu. Wasm. D3.

## sss

# Observable Javascript

xxxxx

## Observable, kezako ?

![](img/observable.png){height="200"}

Observable javascript (ojs) est un extension du langage javascript dÃ©veloppÃ© par la sociÃ©tÃ© Observable.

## Les cellules / chunk {ojs}

Dans Quarto, on peut ecrire/executer du code Observable en utilisant des chuncks **{ojs}**.

Chaque ligne dÃ©finit une variable et une cellule qui doit Ãªtre unique.

cellule 1 :

```{ojs}
a = 5 
```

cellule 2 :

```{ojs}
b = 7 
```

cellule 3 :

```{ojs}
a + b
```

Avec ojs, l'ordre d'Ã©criture n'a pas d'importance ðŸ¤” On peut donc Ã©crire :

Ceci :

```{ojs}
c * d 
```

Avant Ã§a

```{ojs}
c = 3
```

et Ã§a

```{ojs}
d = 8
```

La raison est que la relation entgre les cellules s'effectue de maniÃ¨re topologique.

![](img/topo.png){height="400"}

Chaque cellule doit impÃ©rativement Ãªtre unique. En consÃ©quance, je n'ai pas le droit de redÃ©finir une de ces variables.

```{ojs}
e = 10
e = 5
```

Il est donc souvent utile de crÃ©er des blocs de code avec des {...} quand le traitement devient plus complexe.

```{ojs}
{
  let val1 = 8;
  let val2 = 7;
  val1 = 5;
  return val1 * val2;
}

```

Mais la plupart du temps, pour faire ce genre de calcul, on Ã©crira plutÃ´t des fonctions. Comme ceci :

```{ojs}
function sum(a, b) {
  return a + b;
}
// Appel de la fonction
sum(10, 30)
```

Ou comme cela :

```{ojs}
multi = (a, b) => a * b
// Appel de la fonction
multi(3, 8)
```

Ce parti pris fort, peut Ãªtre dÃ©routant. Mais il a un gros avantage. Il permet d'organiser un document indÃ©pendemment de la faÃ§on dont on code. Cela petrmet par exemple de mettre une carte en haut de la page et en annexe technique tout en bas le code qui la gÃ©nÃ¨re.

## D3.js

![](img/logo-D3.png){height="200"}

D3.js est une bibliothÃ¨que graphique JavaScript dÃ©veloppÃ©e par Mike Bostock qui permet l'affichage de donnÃ©es numÃ©riques sous une forme graphique et dynamique. **d3.js** est une grosse librairie qui fait beaucoup de choses. Depuis 2015, elle est composÃ©e de diffÃ©rents modules spÃ©cialisÃ©s.

![](img/d3github.png)

D3 est directement intÃ©grÃ©e dans Observable javascript. On peut faire par exemple :

```{ojs}
{ 
let values = [0, 10, 30];
return d3.quantile(values, 0.25);
}
```

Et 1000 autres choses qu'on ne dÃ©taillera pas ici.

## Dessiner avec D3.js

Avec D3, il est possible de dessiner des images vectorielles au format SVG.

DOM

Le Document Object Model (DOM) est une interface de programmation normalisÃ©e par le W3C, qui permet Ã  des scripts d'examiner et de modifier le contenu du navigateur web. Par le DOM, la composition d'une page web est reprÃ©sentÃ©e sous forme d'un arbre avec des objets dedans.

CrÃ©er un document svg

```{ojs}
{
  const svg = d3
    .create("svg")
    .attr("viewBox", [0, 0, 500, 60])
    .style("background-color", "#CCC");
    
  return svg.node();
}    
```

Dessiner un cercle

```{ojs}
{
  const svg = d3
    .create("svg")
    .attr("viewBox", [0, 0, 500, 60])
    .style("background-color", "#CCC");
    
  svg
    .append("circle")
    .attr("cx", 50)
    .attr("cy", 30)
    .attr("r", 25)
    .style("fill", "#e04a28");
    
  return svg.node();
}    
```

Dessiner un carrÃ©

```{ojs}
{
  const svg = d3
    .create("svg")
    .attr("viewBox", [0, 0, 500, 60])
    .style("background-color", "#CCC");
    
  svg
    .append("rect")
    .attr("x", 100)
    .attr("y", 5)
    .attr("height", 50)
    .attr("width", 50)
    .style("fill", "#5277bf");
    
  return svg.node();
}    
```

Tracer une ligne

```{ojs}
{
  const svg = d3
    .create("svg")
    .attr("viewBox", [0, 0, 500, 60])
    .style("background-color", "#CCC");

    
  return svg.node();
}    
```

Ecrire un texte

```{ojs}
{
  const svg = d3
    .create("svg")
    .attr("viewBox", [0, 0, 500, 60])
    .style("background-color", "#CCC");
    

  return svg.node();
}    
```

## Dessiner des donnÃ©es avec D3.js et svg

On crÃ©e des donnÃ©es fictives

```{ojs}
myData = [10, 30, 2, 20, 10]
```

On veut crÃ©er des cercles. crÃ©e une fonction pour calculer le rayon.

```{ojs}
valmax = d3.max(myData)
radius = d3.scaleSqrt([0, valmax], [0, 35]);
```

Puis, on dessine un SVG.

```{ojs}
{
  const width = 500;
  const height = 75;
  
  const svg = d3
    .create("svg")
    .attr("viewBox", [0, 0, width, height])

  svg
    .append("g")
    .attr("fill", "#e04a28")
    .selectAll("circle")
    .data(myData)
    .join("circle")
    .attr("cx", (d, i) => 50 + i * 100)
    .attr("cy", height / 2)
    .attr("r", (d) => radius(d));

  return svg.node();
}
```

## Les Inputs

Dans Observable, on a Ã  disposition des *Inputs* directement prÃªts Ã  l'emploi.

### ðŸ‘‰ button

```{ojs}
viewof clicks = Inputs.button("Click")
clicks
```

### ðŸ‘‰ toogle

```{ojs}
viewof mute = Inputs.toggle({label: "Mute", value: true})
mute
```

### ðŸ‘‰ range

```{ojs}
viewof gain = Inputs.range([0, 11], {value: 5, step: 0.1, label: "Gain"})
gain
```

### ðŸ‘‰ checkbox

```{ojs}
viewof colors = Inputs.checkbox(["red", "green", "blue"], {label: "color"})
colors
```

### ðŸ‘‰ radio

```{ojs}
viewof color = Inputs.radio(["red", "green", "blue"], {label: "color"})
color
```

### ðŸ‘‰ select

```{ojs}
villes = ["Cotonou", "Porto-Novo", "Ouidah"]
viewof maville = Inputs.select(villes, {value: "steelblue", label: "Favorite color"})
maville
```

### ðŸ‘‰ text

```{ojs}
viewof text = Inputs.text()
text
```

### ðŸ‘‰ textarea

```{ojs}
viewof textarea = Inputs.textarea()
textarea
```

### ðŸ‘‰ data

```{ojs}
viewof date = Inputs.date()
date
```

### ðŸ‘‰ color

```{ojs}
viewof pickcolor = Inputs.color({label: "couleur prÃ©fÃ©rÃ©e", value: "#4682b4"})
pickcolor
```

### ðŸ‘‰ file

```{ojs}
viewof file = Inputs.file()
file
```

### ðŸ‘‰ formulaire

```{ojs}
//| panel: sidebar
//| echo: false
viewof range1 = Inputs.range([0, 11], {value: 5, step: 0.1, label: "range1"})
viewof range2 = Inputs.range([0, 11], {value: 5, step: 0.1, label: "range2"})
viewof range3 = Inputs.range([0, 11], {value: 5, step: 0.1, label: "range3"})
```

```{ojs}
//| panel: fill
range1
range2
range3

```

## Tout est rÃ©actif ðŸ”¥

Dans Observable, grace Ã  la relation topologique entre les cellules, tout est rÃ©actif. Chaque fois qu'on bouge quelque chose, ce qui en dÃ©pend est rÃ©Ã©xÃ©cutÃ©.

```{ojs}
viewof age = Inputs.range([15, 70], {label: "age", value: 30, step: 1,})
viewof nom = Inputs.text({label: "nom", value: "Nicolas"})
```

Par exemple :

```{ojs}
md`Je m'appelle **${nom}** et j'ai **${age}** ans :-)`
```

Reprenons notre SVG de tout Ã  l'heure

```{ojs}
{
  const svg = d3
    .create("svg")
    .attr("viewBox", [0, 0, 500, 60])
    .style("background-color", "#CCC");
    
  svg
    .append("circle")
    .attr("cx", 50)
    .attr("cy", 30)
    .attr("r", 25)
    .style("fill", "#e04a28");
    
  return svg.node();
}
```

On peut facilement proposer Ã  l'utilisateur de moidifier ce dessin en remplaÃ§ant des valeurs par des variables pilotÃ©es par des inputs.

```{ojs}
//| echo: true
//| eval: false
{
  const svg = d3
    .create("svg")
    .attr("viewBox", [0, 0, 500, 60])
    .style("background-color", "#CCC");
    
  svg
    .append("circle")
    .attr("cx", cx)
    .attr("cy", 30)
    .attr("r", r)
    .style("fill", col);
    
  return svg.node();
}
```

Par exemple :

```{ojs}
//| panel: input
//| echo: false
viewof cx = Inputs.range([30, 470], {value: 50, step: 1, label: "position"})
viewof col = Inputs.color({ value: "#e04a28", label: "couleur"})
viewof r = Inputs.range([5, 30], {value: 25, step: 0.1, label: "rayon"})

```

```{ojs}
//| echo: false
{
  const svg = d3
    .create("svg")
    .attr("viewBox", [0, 0, 500, 60])
    .style("background-color", "#CCC");
    
  svg
    .append("circle")
    .attr("cx", cx)
    .attr("cy", 30)
    .attr("r", r)
    .style("fill", col);
    
  return svg.node();
}
```

## Ajouter des donnÃ©es

L'ajout de donnÃ©es s'effectue avec l'instruction `FileAttachment()`

### ðŸ‘‰ fichier csv

```{ojs}
data1 = FileAttachment("data/afrika_data.csv").csv()
```

Les donnÃ©es sont importÃ©es et converties automatiquement au format json

```{ojs}
//| echo: false
data1
```

Pour les visualiser, on utilise `Inputs.table()`

```{ojs}
Inputs.table(data1)
```

### ðŸ‘‰ fichier xlsx

On peut Ã©galement importer des fichiers excel

```{ojs}
classeur = FileAttachment("data/afrika.xlsx").xlsx()
```

On obtient la liste des feuilles comme cela :

```{ojs}
classeur.sheetNames
```

Puis, on peut choisir la feuille Ã  ouvrir

```{ojs}
data2 = classeur.sheet("data", {
  headers: true
})
```

```{ojs}
//| echo: false
data2
```

### ðŸ‘‰ fichier geoJSON

Pour utiliser des gÃ©omÃ©tries, on utilisera prioritairement le format geoJSON.

```{ojs}
basemap = FileAttachment("data/africa.json").json()
```

VoilÃ  la structure d'un geoJSON

```{ojs}
//| echo: false
basemap
```

## Librairies externes

Observable javascript n'est pas un Ã©cosystÃ¨me fermÃ©. Des millions de librairies javascript existent sur NPM (Ã©quivalent du CRAN pour R). Il est possible de les utiliser.

*https://www.npmjs.com/* ![](img/npm.png)

Ici, nous pouvons les importer directement avec l'instruction `require()`

```{ojs}
geo = require("geoverview@1.2.1")
```

Version locale

```{ojs}
geo2 = require("lib/geoverview_1.2.1.js")
```

Je peux maintenant utiliser la fonction view du package `geoverview` (qui est reniommÃ© ici, geo).

```{ojs}
geo.view(basemap)
```

## Imports

On l'a dit tout Ã  l'heure, Observable c'est aussi une plateforme web hebergeant des notebooks.

![](img/trendings.png)

Si on a une connexion internet, il ets possible d'importer n'importe quelle cellule de n'importe quel notebook avec la fonction `import`.

```{ojs}
import { SummaryTable } from "@observablehq/summary-table"
```

Puis, on peut utiliser cette fonction sur nos donnÃ©es.

```{ojs}
SummaryTable(data1)
```

## InteropÃ©rabilitÃ© R et OJS

Dans `Quarto`, il ets possible de combiner du code en R et du code en OJS.

# La libraririe bertin

Une librairie javascript pour la cartographie thÃ©matique

## Principes

![](img/logobertin.svg)

```{ojs}
bertin = require("bertin@latest")
```

![](img/level.png)

## PrÃ©paration des donnÃ©es

Import des donnÃ©es sur les pays du monde

Les gÃ©omÃ©tries

```{ojs}
world = FileAttachment("data/world.json").json()
```

```{ojs}
//| echo: false
world
```

Les donnÃ©es attributaires

```{ojs}
stats = FileAttachment("data/worldbank_data.csv").csv()
```

On ne garde que l'annÃ©es 2019

```{ojs}
stats2019 = stats.filter(d => d.date == 2019)
```

```{ojs}
//| echo: false
stats2019
```

On rÃ©alise une jointure grace aux fonctionnalitÃ©s `match` et `merge` disponibles dans `bertin`.

```{ojs}
bertin.match(world, "id", stats2019, "iso3c")
```

Le niveau de compatibiliotÃ© est bon. On rÃ©alise la jointure et on crÃ©e le nouveau jeu de donnÃ©es `world2019`

```{ojs}
world2019 = bertin.merge(world, "id", stats2019, "iso3c")
```

VoilÃ  le rÃ©sultat

```{ojs}
geo.view(world2019)
```

## Syntaxe

![](img/bertin_code.png)

## Types

![](img/types.jpeg){width:100%}

## Carte simple

La fonction `draw` permet de dessiner n'importe quel type de carte.

```{ojs}
bertin.draw({ layers: [ {geojson: world} ] })
```

## Symboles proportionnels

## 
