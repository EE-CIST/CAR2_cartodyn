---
title: "TP1 - Savoir faire des cartes interactives avec Quarto et `bertin`"
format: 
  html:
    theme: custom.scss
    code-tools: true
    toc: false
    code-fold: false
    code-summary: "Show the code"
editor: visual
execute:
  echo: true
---

**L'objectif de ce TP est d'apprendre √† cr√©er des cartes interactives avec Quarto et la biblioth√®que JavaScript `bertin`.**

![](img/banner.png)

**Responsables p√©dagogiques**

Manhamady OUEDRAOGO (Burkina Faso) & Nicolas LAMBERT (France)

**Ont particip√© √† l'√©laboration de ce module**

Claude GRASLAND (France), Souleymane Sidi TRAORE (Mali), Malika MADELIN (France), S√©bastien REY-COYREHOURCQ (France), Vakaramoko BAMBA (C√¥te d'Ivoire), Hugues PECOUT (France), Yentougle MOUTORE (Togo), B√©n√©dicte GARNIER (France), C√¥omlan Charles HOUNTON (B√©nin), Pauline GLUSKI (France).

# 1. D√©marrer avec Quarto

## 1.1 Environnement logiciel.

Ce TP s'effectue avec le logiciel **Quarto**. Pour l'installer, vous poyvez utliser les liens suivants :

- Windows : [	quarto-1.2.335-win.msi](https://github.com/quarto-dev/quarto-cli/releases/download/v1.2.335/quarto-1.2.335-win.msi)
- Mac OS : [quarto-1.2.335-macos.pkg](https://github.com/quarto-dev/quarto-cli/releases/download/v1.2.335/quarto-1.2.335-macos.pkg)
- Ubuntu 18+/Debian 10+ : [quarto-1.2.335-linux-amd64.deb](https://github.com/quarto-dev/quarto-cli/releases/download/v1.2.335/quarto-1.2.335-linux-amd64.deb) 
- Autre : [Voir sur quarto.org](https://quarto.org/docs/get-started/)

Puis, vous avez besoin d'une interface de d√©veloppement pour √©crire le code et visualiser le r√©sultat. Vous avez le choix.

![](img/ide.png)

Dans ce TP, nous privil√©gions l'utilisation du logiciel **Rstudio**. Pour le t√©l√©charger et l'installer, clickez sur ce [lien](https://posit.co/download/rstudio-desktop/).

## 1.2 Cr√©er un document Quarto

- Sur votre ordinateur, creez un dossier **TP1** √† l'emplacement de votre choix. 
- Ouvrez le logiciel RStudio
- Cr√©ez un document Quarto (file \> New File \> Quarto Document)

![](img/create.png)

- Cliquez sur "Create Empty Document" en bas √† gauche.
- Choisissez un titre

Vous obtenez un fichier contenant les lignes suivantes : 

```
---
title: "Mon premier notebook Quarto"
format: html
editor: visual
---
```

- Sauvegardez le fichier **index.qmd** dans le dossier TP1.
- Dans le repertoire **TP1**, cr√©ez √©galement un sous r√©p√©rtoire **data** pour mettre les donn√©es et eventuellement un repertoire **lib** pour un stocker les biblioth√®ques JavaScript que nous allons utiliser. 

![](img/dossiers1.png)

## 1.3 Rappel des principes

Dans ce TP, nous allons r√©aliser des cartes avec **Observable JavaScript** (ou **ojs**). Rappelons que l'ojs est un ensemble d'am√©liorations apport√©es √† JavaScript avec l'objectif d'en faire un langage d√©di√© √† la visualisation de donn√©es pour le web. Ce langage est compl√®tement int√©gr√© dans Quarto.

Les caract√©ristiques de l'ojs sont les suivantes :

- Il s'agit de JavaScript + des biblioth√®ques pr√©charg√©es comme `Plot` & `d3js` üìä
-  Tout est r√©actif üî• et rejou√© en temps r√©el
- L'ordre des cellules n'a pas d'importance ü§Ø
- Chaque d√©but de ligne identifie une *cellule* ojs. Le nom de ces *cellules* doit √™tre unique pour l'ensemble du document.

Dans Quarto, toutes les instructions √† suivre s'√©crivent dans des chunks ojs

``` {{ojs}}
```

Pour chaque *chunck*, vous pouvez d√©finir avec `echo` si vous souhaitez que le code s'affiche ou non dans votre notebook final. Avec `eval`, vous choisissez si le code doit s'executer ou non.

``` {{ojs}}
//| echo: false
//| eval: true
```

Pour g√©n√©rer le document, il faut clicher sur le bouton `Render` ou utiliser le racourci clavier **Ctrl+Shift+K**.

Une fois que vous avez cliqu√© sur *Render*, la page web s'affiche dans la panneau *Viewer* et deux nouveaux √©l√©ments sont cr√©√©s dans votre r√©pertoire de travail : le fichier **index.html** et le dossier **index_files**.

![](img/dossiers2.png)

Vous pouvez aussi cliquer sur l'ic√¥ne *voir das une nouvelle fen√™tre* pour visualiser votre document dans votre navigateur web habituel.

![](img/view.png)

N'oubliez pas de sauvegarder votre document r√©guli√®rement.

## 1.4 Documentation et exemples

Au fil de ce notebook, vous pourrez vous r√©f√©rer √† des √©l√©ments de documentation en cliquant sur cet ic√¥ne.

![](img/logo_doc.png)

Vous pourrez √©galement acc√©der √† des exemples p√©dagogiques et des demos en ligne en cliquant sur celui-l√†.

![](img/logo_exemple.png)

# 2. Les donn√©es

Le jeu de donn√©es utilis√© concerne les pays africains. Nous avons un fond de carte contenant la g√©om√©trie des pays. Et un tableau de donn√©es issu du *Human Development Report 2020* et du *CEPII*, contenant diff√©rentes donn√©es statistiques, qualitatives ou quantitatives.

T√©l√©chargez les donn√©es et mettez-les dans votre repertoire **data**.

<a href = "https://github.com/EE-CIST/CART3_cartodyn/raw/main/TP1/data/data.zip"><img src = "img/download.png" height= "50px"><img></a>

## 2.1 Import des donn√©es attributaires

Dans {ojs}, on importe les donn√©es avec l'instruction `FileAttachment()` <a href="https://github.com/observablehq/stdlib#file-attachments"><img src="img/logo_doc.png"/></a>

La fonction `.xlsx()` <a href="https://observablehq.com/@observablehq/xlsx"><img src="img/logo_exemple.png"/></a> permet d'importer des tableurs excel.

La ligne ci-dessous permet donc d'importer un classeur excel et de l'interpr√©ter. 

```{ojs}
classeur = FileAttachment("data/afrika.xlsx").xlsx()
```

`classeur.sheetNames` permet de voir la liste des feuilles contenues dans le classeur excel

```{ojs}
classeur.sheetNames
```

Visualisons les metadonn√©es avec `Inputs.table()` <a href="https://github.com/observablehq/inputs#inputstabledata-options"><img src="img/logo_doc.png"/></a>

```{ojs}
Inputs.table(classeur.sheet("meta", {headers:true}))
```

Et cr√©ons une variable `data` contenant les donn√©es de feuille data

```{ojs}
data = classeur.sheet("data", {headers:true})
```

Visualisons-la.

```{ojs}
Inputs.table(data)
```

## 2.2 Import des donn√©es g√©om√©triques

Import du fond de carte

```{ojs}
countries = FileAttachment("data/africa.json").json()
```

Le fond de carte est au format geoJSON

```{ojs}
countries
```

Pour la visualiser, on a besoin d'importer une biblioth√®que de cartographie. Ici, on choisit la biblioth√®que `bertin` <a href="https://github.com/neocarto/bertin"><img src="img/logo_doc.png"/></a> On l'importe grace √† l'instruction `require()`.

```{ojs}
bertin = require("bertin@1.6.3")
```

*Nb : pour travailler offline, vous pouvez aussi t√©l√©charger la librairie bertin [ici](https://cdn.jsdelivr.net/npm/bertin@1.6.3) et indiquer son emplacement. Par exemple si vous le mettez dans le repertoire __lib__ : *

```{ojs}
//| eval: false
bertin = require("./lib/bertin.js")
```

La fonction `quickdraw()` <a href="https://observablehq.com/@neocartocnrs/bertin-js-quickdraw-table2geo"><img src="img/logo_exemple.png"/></a> permet de visualiser rapidement n'importe quel fond de carte. Le second param√®tre permet de d√©finir la largeur de la carte (en pixels). La hauteur est d√©duite automatiquement. La couleur est choisie al√©atoirement.

```{ojs}
bertin.quickdraw(countries, 500)
```

Pour r√©cup√©rer la table attributaire, on utilise l'instruction `bertin.properties.table()` <a href="https://github.com/neocarto/bertin#propertiestable"><img src="img/logo_doc.png"/></a>. Puis, on peut la visualiser sous forme de tableau avec `Inputs.table()`.

```{ojs}
Inputs.table(bertin.properties.table(countries))
```

# 2. Cr√©ation de cartes statiques

## 2.1 Jointure

La premi√®re chose √† faire est de r√©aliser une jointure entre les donn√©es et le fond de carte. Pour cela, on va proc√©der en 2 √©tapes. `bertin.match` <a href="https://github.com/neocarto/bertin#match"><img src="img/logo_doc.png"/></a> permet de tester et visaliser le compatibilit√© entre le fond de carte et le tableau de donn√©es. `bertin.merge` <a href="https://github.com/neocarto/bertin#merge"><img src="img/logo_doc.png"/></a> permet d'effectuer r√©ellement cette jointure. <a href="https://observablehq.com/@neocartocnrs/bertin-js-match-and-merge?collection=@neocartocnrs/bertin"><img src="img/logo_exemple.png"/></a>

```{ojs}
test = bertin.match(countries, "id", data, "iso3")
```

On constate que le jeu de donn√©es et le fond de carte sont compatibles √† 98%. Toutes les donn√©es disponibles dans le jeu de donn√©es peuvent √™tre jointe avec le fond de carte (49/49). Seule une unit√© g√©ographique dans le fond de carte n'a pas d'&quivalent dans le tableau de donn√©es (49/50). Pour savoir de quelle unit√© il s'agit, on peut taper `test.unmatched_geom`

```{ojs}
test.unmatched_geom
```

Il s'agit du Sahara Occidental. Il n'y a en effet pas de donn√©es pour cette unit√© g√©ographique. On peut donc d√©cider d'effecter la jointure pour de bon et de cr√©er un nouvel objet `africa`. Cet objet contient √† la fois les donn√©es et les g√©om√©tries.

```{ojs}
africa = bertin.merge(countries, "id", data, "iso3")
```

## 2.2 R√©aliser des cartes avec `bertin`

Pour r√©aliser une carte avec la biblioth√®que `bertin`, on utilise la fonction `draw()` <a href="https://github.com/neocarto/bertin#drawing-a-map"><img src="img/logo_doc.png"/></a>.

La fonction prend en entr√©e un objet avec la structure suivante <a href="https://observablehq.com/@neocartocnrs/hello-bertin-js?collection=@neocartocnrs/bertin"><img src="img/logo_exemple.png"/></a> :

![](img/bertin_code.png)

Ainsi, on peut √©crire :

```{ojs}
bertin.draw({
  params : {width : 500, background: "#CCC", margin: 20}, 
  layers :
    [
      {geojson: africa, fill: "#e07edd"},
      {type: "header", text: "Le continent africain"},
      {type: "scalebar"}
    ]
  })
```

üí° Les noms des param√®tres de la fonction `draw` reprennent la plupart du temps les noms des attributs SVG. Par exemple : 

- `fill` permet de d√©finir la couleur de fond d'un objet
- `stroke` permet de d√©finir la couleur de contour d'un objet

Pour les attributs contenant un tiret, la r√®gle classique en JavaScript est de remplacer le tiret par une √©criture en CamelCase. Ainsi : 

- `fillOpacity` permet de modifier l'attribut *fill-opacity* qui d√©finit la transparence du fond.
- `strokeOpacity` permet de modifier l'attribut *stroke-opacity* qui d√©finit la transparence du contour.
- `strokeWidth` permet de modifier l'attribut *stroke-width* qui d√©finit la l'√©paisseur des traits.
- `strokeDasharray` permet de modifier l'attribut *stroke-dasharray* qui permet de d√©finir des motifs de pointill√©s.
- Etc.

Tous les param√®tres sont d√©taill√©s dans la documentation <a href="https://github.com/neocarto/bertin"><img src="img/logo_doc.png"/></a>


**Nous allons √† pr√©sent r√©aliser des cartes th√©matiques.**

Rappel : le type de carte th√©matique qu'on va r√©aliser d√©pend du type de donn√©es √† repr√©senter.

## 2.3. Cartographier des donn√©es quantitatives absolues (stock)

En cartographie, on repr√©sente des donn√©es quantitatives absolues avec la variable visuelle TAILLE. Pour avoir des cercles proportionnels, dans `bertin`, on utilisera le type `bubble` <a href="https://github.com/neocarto/bertin#bubble"><img src="img/logo_doc.png"/></a><a href="https://observablehq.com/@neocartocnrs/bertin-js-prop-symbols?collection=@neocartocnrs/bertin"><img src="img/logo_exemple.png"/></a>

Trois param√®tres sont absolement n√©c√©ssaires √† l'affichage de la couche cercles proportinnels : 

- `type` : le type de repr√©sentation (ici `bubble`)
- `geojson` : l'objet geoJSON contenant les g√©om√©tries et les donn√©es atributaires.
- `values` : le nom de la variable √† cartographier.

Le reste est optionnel. 

Dans l'exemple ci-dessous, on utilise aussi les types `header` <a href="https://github.com/neocarto/bertin#header"><img src="img/logo_doc.png"/></a> et `scalebar` <a href="https://github.com/neocarto/bertin#scalebar"><img src="img/logo_doc.png"/></a> qui permettent respectivement d'ajouter un titre et une barre d'√©chelle. 

```{ojs}
bertin.draw({
  params : {width : 500, background: "#CCC", margin: 20}, 
  layers :
    [
      {
        type : "bubble", 
        geojson: africa,
        values: "POP",
        k: 50, // rayon du plus grand cercle
        fill: "red",
        leg_x: 30,
        leg_y: 300,
        leg_round: 0,
        leg_title: "Nombre d'habitants\n (en millions)"
      },
      {geojson: africa, fill: "#DDD"},
      {type: "header", text: "Le continent africain"},
      {type: "scalebar"}
    ]
  })
```

D'autres modes de repr√©sentation auraient bien s√ªr √©t√© possibles. On aurait √©galement pu faire des *squares* <a href="https://observablehq.com/@neocartocnrs/bertin-js-prop-squares?collection=@neocartocnrs/bertin"><img src="img/logo_exemple.png"/></a> ou des *spikes* <a href="https://observablehq.com/@neocartocnrs/bertin-js-spikes?collection=@neocartocnrs/bertin"><img src="img/logo_exemple.png"/></a>

## 2.4 Cartographier des donn√©es qualitatives nominales

Il y a plusieurs fa√ßons de cartographier des donn√©es qualitatives nominales. Sur √©cran, en cartographie num√©rique, on choisra la plupart du temps la variable visuelle COULEUR (teinte).

Dans `bertin`, il s'agit donc de faire varier la propri√©t√© `fill` et de la faire varier en fonction d'une donn√©e qualitative. Pour cela, on utilise le type `typo` <a href="https://github.com/neocarto/bertin#typology"><img src="img/logo_doc.png"/></a><a href="https://observablehq.com/@neocartocnrs/bertin-js-typo?collection=@neocartocnrs/bertin"><img src="img/logo_exemple.png"/></a> √† l'interieur de la propri√©t√© `fill`.

```{ojs}
bertin.draw({
  params : {width : 500, background: "#CCC", margin: 20}, 
  layers :
    [
      {
        geojson: africa, 
        fill: {
                type : "typo",
                values: "SUBREG",
                leg_x: 30,
                leg_y: 330,
                leg_title: "Sub regions",
                txt_missing: "Pas de donn√©es",
                pal: "Tableau10",
              }
      },
      {type: "header", text: "Le continent africain"},
    ]
  })
```

La palette de couleurs par d√©faut est `Tableau10`. Mais il est possible d'en choisir une autre : `Category10`, `Accent`, `Dark2`, `Paired`, `Pastel1`, `Pastel2`, `Set1`, `Set2` ou `Set3` <a href="https://observablehq.com/@d3/color-schemes"><img src="img/logo_exemple.png"/></a>.

Il est aussi possible de d√©finir vos propres couleurs en repla√ßant `pal: "Tableau10"` par `colors: ["#8dd3c7","#ffffb3","#bebada","#fb8072","#80b1d3"]`.

## 2.5 Cartographier des donn√©es quantitatives relatives (ratio, indice)

Il y a plusieurs fa√ßons de cartographier des donn√©es quantitatives relatives. Sur √©cran, en cartographie num√©rique, on choisra la plupart du temps de r√©aliser une carte choropl√®the avec des couleurs ordonn√©es. Un √©tape de discr√©tisation pr√©alable est n√©c√©ssaire. Elle n√©cessite d'√©tudier la forme de la distribution statistique. Pour cel√†, on utilisera la librairie `Plot` <a href="https://github.com/observablehq/plot"><img src="img/logo_doc.png"/></a> <a href="https://observablehq.com/collection/@observablehq/plot"><img src="img/logo_exemple.png"/></a> disponible nativement dans les celles `{ojs}`.

Il y a plusieurs fa√ßons de visualister la forme d'une distribution <a href="https://observablehq.com/@cartographie/les-discretisations?collection=@cartographie/cours"><img src="img/logo_exemple.png"/></a> Ici, on choisira un graphique avec des points et une transformation de type dodge.

```{ojs}
Plot.plot({
  height: 60,
  marks: [
    Plot.dotX(
      data,
      Plot.dodgeY({ x: "IDH", fill: "red" })
    )
  ]
})
```

Pour faire une carte choropl√®the dans `bertin`, on fait varier comme pr√©c√©demment la propri√©t√© `fill`. Pour cela, on utilise le type `choro` <a href="https://github.com/neocarto/bertin#choropleth"><img src="img/logo_doc.png"/></a> <a href="https://observablehq.com/@neocartocnrs/bertin-js-chropoleth?collection=@neocartocnrs/bertin"><img src="img/logo_exemple.png"/></a>

Les m√©thodes de discr√©tisation disponibles son celles contenues dans la libraire `statsbreaks` <a href="https://observablehq.com/@neocartocnrs/hello-statsbreaks"><img src="img/logo_exemple.png"/></a> : `quantile`, `q6`, `geometric`, `jenks`, `msd` (moyenne √©cart-type) et `equal`. Pour les couleurs, de nombreuses palettes sont disponibles : `Blues`, `Greens`, `Greys`, `Oranges`, `Purples`, `Reds`, `BrBG`, `PRGn`, `PiYG`, `PuOr`, `RdBu`, `RdYlBu`, `RdYlGn`, `Spectral`,`Turbo`,`Viridis`,`Inferno`, `Magma`, `Plasma`, `Cividis`, `Warm`, `Cool`, `CubehelixDefault`, `BuGn`, `BuPu`, `GnBu`, `OrRd`, `PuBuGn`, `PuBu`, `PuRd`, `RdPu`, `YlGnBu`, `YlGn`, `YlOrBr`, `YlOrRd`, `Rainbow`, `Sinebow` <a href="https://observablehq.com/@d3/color-schemes"><img src="img/logo_exemple.png"/></a>

Par d√©faut, la m√©thode choisie est `quantile`, la palettes est `Blues` et le nombre de classes est √©gal √† 5.

```{ojs}
bertin.draw({
  params : {width : 500, background: "#CCC", margin: 20}, 
  layers :
    [
      {
        geojson: africa, 
        fill: {
                type : "choro",
                values: "IDH",
                leg_x: 30, // position de la l√©gende en x
                leg_y: 330, // position de la l√©gende en y
                leg_round: 2, // 2 chiffres apr√®s la virgule
                leg_title: "IDH",
                txt_missing: "Pas de donn√©es",
                method: "quantile",
                nbreaks: 4,
                colors: "OrRd"
              }
      },
      {type: "header", text: "Indicateur de d√©veloppement humain"},
    ]
  })
```

# 3. Faire des cartes interactives

Avec Observable JavaScript, nous sommes dans un √©cosyst√®me pleinement r√©actif üî• Cela signifie qu'il est possible de proposer √† l'utilisateur des possibilit√©s d'interaction avec la carte. 


## 3.1 Une carte par symbols proportionnels

Reprenons le cas de de la carte par symboles proportionnels de tout √† l'heure et redons-l√† interactive avec des `Inputs` <a href="https://github.com/observablehq/inputs"><img src="img/logo_doc.png"/></a> <a href="https://observablehq.com/@observablehq/inputs"><img src="img/logo_exemple.png"/></a>

```{ojs}
viewof k = Inputs.range([10, 75], { label: "Taille", step: 1, value: 40 })
viewof symbol = Inputs.radio(["bubble", "square", "spikes"], { label: "Symbole", value: "bubble" })
viewof color = Inputs.color({label: "Couleur", value: "#CC0000"})
viewof toggle = Inputs.toggle({label: "Ecarter les symboles", value: false})
```

Puis, nous recopions le code de la carte en rempla√ßant les valeurs *en dur* par les valeurs issues des `Inputs`.

```{ojs}
//| echo: false
//| eval: true
bertin.draw({
  params : {width : 500, background: "#CCC", margin: 20}, 
  layers :
    [
      {
        type : symbol, 
        geojson: africa,
        values: "POP",
        k: k, // rayon du plus grand cercle
        fill: color,
        stroke: "white",
        dorling: toggle,
        leg_x: 30,
        leg_y: 300,
        leg_round: 0,
        leg_title: "Nombre d'habitants\n(en millions)",
        //tooltip: ["$name", "$POP"]
        tooltip: ["$name", d => Math.round(d.properties.POP) + " millions d'habitants"]        
      },
      {geojson: africa, fill: "#DDD"},
      {type: "header", text: "Le continent africain"},
      {type: "scalebar"}
    ]
  })
```


Il est √©galement possible d'ajouter des infobulles grace √† la propri√©t√© `tooltip` <a href="https://observablehq.com/@neocartocnrs/bertin-js-tooltips?collection=@neocartocnrs/bertin"><img src="img/logo_exemple.png"/></a>

```{ojs}
//| echo: true
//| eval: false
bertin.draw({
  params : {width : 500, background: "#CCC", margin: 20}, 
  layers :
    [
      {
        type : symbol, 
        geojson: africa,
        values: "POP",
        k: k, // rayon du plus grand cercle
        fill: color,
        stroke: "white",
        dorling: toggle,
        leg_x: 30,
        leg_y: 300,
        leg_round: 0,
        leg_title: "Nombre d'habitants\n(en millions)",
        //tooltip: ["$name", "$POP"]
        tooltip: ["$name", d => Math.round(d.properties.POP) + " millions d'habitants"]        
      },
      {geojson: africa, fill: "#DDD"},
      {type: "header", text: "Le continent africain"},
      {type: "scalebar"}
    ]
  })
```

## 3.2 Carte qualitative

Il peut √™tre souvent interessant de demander √† l'utilisateur de choisir lui m√™me l'indicateur qu'il souhaite cartographier. Pour cela, on peut le proposer dans une liste d√©roulante <a href="https://observablehq.com/@observablehq/input-select"><img src="img/logo_exemple.png"/></a>. Par exemple, on peut mettre dans un `array` , les indicateurs qualitatifs du tableau de donn√©es issus du CEPII :

```{ojs}
indicators = ["LOCKED", "COLFRA", "COLGBR", "LANGFR", "LANGEN"]
```

Puis, les utiliser dans une liste d√©roulante

```{ojs}
viewof myindicator1 = Inputs.select(indicators, {value: "LOCKED", label: "Choisissez votre indicateur"})
```

```{ojs}
//| echo: false
//| eval: true
myindicator1
```

Si on veut les labels dans la liste d√©roule, c'est un petit plus compliqu√©. Une fa√ßon de faire est de cr√©er un `array` contenant √† la fois les noms de variable et les labels. 

```{ojs}
indicators2 = [
  ["Pays enclav√©", "LOCKED"],
  ["Colonisation par la France", "COLFRA"],
  ["Colonisation par le Royaume-Uni", "COLGBR"],
  ["Langue officielle fran√ßaise", "LANGFR"],
  ["Langue officielle anglaise", "LANGEN"]
]
```

Puis, on utilise utilise cet `array` sous forme de `Map` JavaScript (clef/valeur).

```{ojs}
viewof myindicator2 = Inputs.select(new Map(indicators2), {value: "LANGEN", label: "Choisissez votre indicateur", width:300})
```

```{ojs}
//| echo: false
//| eval: true
myindicator2
```

On peut r√©cup√©rer le label de la fa√ßon suivante : 

```{ojs}
mytitle = indicators2.find((d) => d[1] == myindicator2)[0]
```

```{ojs}
//| echo: false
//| eval: true
mytitle
```

Dans `bertin`, il ne reste plus qu'√† utiliser *myindicator2* comme nom de variable.

```{ojs}
//| echo: false
//| eval: true
bertin.draw({
  params : {width : 500, background: "#CCC", margin: 20}, 
  layers :
    [
      {
        geojson: africa,
        fill: {
          type:"typo", 
          values: myindicator2,
          colors : ["#3baee3","#DDD"],
          order:[1,0]
          }
      },
      {type: "header", text: mytitle},
      {type: "scalebar"}
    ]
  })
```

```{ojs}
//| echo: true
//| eval: false
bertin.draw({
  params : {width : 500, background: "#CCC", margin: 20}, 
  layers :
    [
      {
        geojson: africa,
        fill: {
          type:"typo", 
          values: myindicator2,
          colors : ["#3baee3","#DDD"],
          order:[1,0]
          }
      },
      {type: "header", text: mytitle},
      {type: "scalebar"}
    ]
  })
```

## 3.3 Habillage et mise en page

Ici, on ne souhaite plus voir "flotter" l'Afrique. Donc, on importe un nouveau fichier contenant les pays du Monde. Cette couche servira √† l'habillage. Dans les param√®tres g√©n√©raux de la carte, il faudra bien penser √† d√©finir l'`extent` (l'√©tendue) pour que la carte ne s'affiche pas √† l'√©chelle mondiale.

```{ojs}
world = FileAttachment("data/world.json").json()
```

De plus, pour am√©liorer la carte pr√©c√©dente, on rajoute quelques couches d'habillage comme `shadow`<a href="https://github.com/neocarto/bertin#shadow"><img src="img/logo_doc.png"/></a> et `hatch` <a href="https://github.com/neocarto/bertin#hatch-or-hatching"><img src="img/logo_doc.png"/></a>


Puis, pour faire varier la carte pr√©c√©dente, on choisi de repr√©senter les donn√©es avec le type `dotcartogram` qui d√©compose chaque cercle en un nombre de points de m√™me valeurs, plac√©s sur le centroid <a href="https://github.com/neocarto/bertin#dot-cartogram"><img src="img/logo_doc.png"/></a><a href="https://observablehq.com/@neocartocnrs/bertin-js-dots-cartograms?collection=@neocartocnrs/bertin"><img src="img/logo_exemple.png"/></a>. Le reste s'√©crit grosso modo comme la carte pr√©c√©dente.


```{ojs}
viewof radius = Inputs.range([1, 15], { label: "Rayon", step: 0.5, value: 7})
viewof onedot = Inputs.range([1, 20], {
  label: "Valeur du point (en millions)",
  step: 1,
  value: 10
})

bertin.draw({
  params : {width : 500, background: "#8ddaf0", margin: 20, extent: africa}, 
  layers :
    [
      {type: "header", text: "Le continent africain"},
      {
        type : "dotcartogram", 
        geojson: africa,
        values: "POP",
        radius: radius, 
        onedot: onedot,
        fill: color,
        stroke: "white",
        dorling: toggle,
        leg_x: 30,
        leg_y: 300,
        leg_round: 0,
        leg_title: "Nombre d'habitants\n(en millions)",
        //tooltip: ["$name", "$POP"]
        tooltip: ["$name", d => Math.round(d.properties.POP) + " millions d'habitants"]        
      },
      {geojson: africa, fill: "#DDD"},
      {type:"shadow", geojson:africa},
      {geojson:world, fill:"white", fillOpacity:0.5, stroke: "none"},
      {type:"hatch"},
      {type: "scalebar"}
    ]
  })
```


# 4. √Ä vous de jouer

::: up2u
Choisissez une donn√©e quantitative relative √† cartographier dans la liste suivante (sauf l'idh):

```{ojs}
//| echo: false
//| eval: true
Inputs.table(classeur.sheet("meta", {headers:true, columns : ["Code", "D√©finition"]}))
```

R√©alisez une carte chorop√®the avec `bertin` en faisant varier :

-   la palette de couleurs via une liste d√©roulante <a href="https://observablehq.com/@observablehq/input-select?collection=@observablehq/inputs"><img src="img/logo_exemple.png"/></a>
-   le nombre de classes via un slider <a href="https://observablehq.com/@observablehq/input-range?collection=@observablehq/inputs"><img src="img/logo_exemple.png"/></a>


*NB : N'oubliez pas d'analyser la distribution statistique pour choisir la bonne m√©thode de discr√©tisation.*
:::



